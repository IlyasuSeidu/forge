# Build Prompt Execution Contract

## Overview

Every build prompt generated by the **Build Prompt Engineer** includes a complete, deterministic **execution contract** that specifies exactly what a Forge Implementer (execution agent) is allowed and forbidden to do.

This contract eliminates ambiguity, prevents scope creep, and enables safe, automated code generation.

## Why Execution Contracts Exist

Traditional AI code generation fails because:
- **Ambiguity**: "Implement auth" can mean 50 different things
- **Scope Creep**: LLMs invent features not in requirements
- **File Conflicts**: Multiple prompts try to modify the same files
- **Dependency Chaos**: Dependencies redeclared or versions conflict
- **No Verification**: No way to prove the output matches intent

**Execution contracts solve this** by making every build prompt:
- **Explicit**: Lists every file that can be touched
- **Bounded**: Defines forbidden zones (conductor, verification, rules)
- **Deterministic**: Same prompt = same allowed operations
- **Auditable**: Contract stored in database, fully traceable

## Contract Structure

Every build prompt includes these mandatory sections:

### 1. Allowed File Operations

#### Files to CREATE
Lists new files the implementer must create.
- Must not already exist in ledger
- Must be relative paths inside project root
- Example: `src/auth/jwt-utils.ts`

#### Files to MODIFY (PATCH ONLY)
Lists files that can be partially modified (patches/additions).
- Implies existing code must be preserved
- Safe for adding new exports, functions, routes
- Example: `src/index.ts` (to add new route)

#### Files to MODIFY (FULL REWRITE)
Lists files that can be completely rewritten.
- Existing content will be replaced
- Use sparingly - only when refactoring is required
- Example: `src/legacy-module.ts` (deprecated, needs rewrite)

#### Files FORBIDDEN to Touch
Lists files that must never be modified.
- Always includes: `prisma/schema.prisma`, `src/conductor/**`, verification logic, project rules
- Implementer must throw error if any forbidden file is needed

### 2. Dependency Changes

#### New Dependencies
Lists production dependencies to install.
- Format: `package@version`
- Example: `express@^4.18.2`
- Deduplicated against ledger (won't redeclare if already installed)

#### Dev Dependencies
Lists development dependencies to install.
- Format: `package@version`
- Example: `@types/node@^20.0.0`

#### Rationale
Explains why each dependency is required.
- Format: `package: reason`
- Example: `jsonwebtoken: JWT token generation/validation`
- **Required** if any dependencies declared

### 3. Modification Intent

For each file (create/modify/rewrite), specifies:
- **Intent**: What this change accomplishes
- **Constraints**: What must NOT be changed

Example:
```
**src/auth/auth-service.ts**
- Intent: Implement JWT-based authentication service
- Constraints:
  - Follow project rules
  - Maintain existing API contracts
```

This section enables verification - the Forge Implementer's output can be checked against stated intent.

## Build Ledger

Before generating each prompt, Build Prompt Engineer queries all **previously approved prompts** to build a ledger:

- **filesCreated**: Files already created
- **filesModified**: Files already patched
- **filesFullRewrite**: Files already rewritten
- **dependenciesAdded**: Packages already installed

### Conflict Detection

If a new prompt tries to:
- Create a file that already exists → **ERROR**
- Declare a dependency already installed → **SKIP** (not an error, just deduplicated)

This ensures **file ownership** - each file is created by exactly one prompt, preventing merge conflicts.

## Validation Rules

Every execution contract is validated before approval:

1. **No Overlap**: Allowed files cannot appear in forbidden list
2. **Relative Paths**: All file paths must be relative, no `../` escapes
3. **Dependency Rationale**: If deps declared, rationale must exist
4. **Modification Intent**: All files must have intent specified
5. **Ledger Compliance**: No file ownership conflicts

If validation fails → prompt generation throws error → human investigates.

## How Forge Implementer Will Use This

When Forge Implementer (Tier 5) receives a build prompt:

1. **Parse Contract**: Extract allowedCreateFiles, forbiddenFiles, etc. from database
2. **Pre-Flight Check**: Verify no forbidden files needed for task
3. **Install Dependencies**: Run `npm install` for declared packages
4. **Generate Code**: Write files according to contract
5. **Post-Flight Verification**:
   - All created files match contract
   - No forbidden files touched
   - All dependencies installed
   - Code passes verification agent
6. **Commit**: Atomic commit with contract metadata

If any step fails → rollback → report error → pause for human.

## Example Contract

### Scaffolding Phase

```markdown
## Allowed File Operations

### Files to CREATE
- package.json
- tsconfig.json
- .gitignore
- README.md
- src/index.ts
- src/types.ts

### Files to MODIFY (PATCH ONLY)
- (none)

### Files to MODIFY (FULL REWRITE)
- (none)

### Files FORBIDDEN to Touch
- prisma/schema.prisma
- prisma/migrations/**/*
- src/conductor/**/*
- src/agents/verification-agent.ts
- docs/PROJECT_RULES.md

## Dependency Changes

### New Dependencies
- express@^4.18.2
- dotenv@^16.0.3

### Dev Dependencies
- typescript@^5.0.0
- @types/node@^20.0.0
- @types/express@^4.17.17

### Rationale
- express: Web server framework
- dotenv: Environment variable management
- typescript: Type-safe development

## Modification Intent

**package.json**
- Intent: Initialize Node.js project with required dependencies
- Constraints:
  - Follow project rules
  - Maintain existing API contracts

**src/index.ts**
- Intent: Create main application entry point
- Constraints:
  - Follow project rules
  - Maintain existing API contracts
```

## Benefits

### For Build Prompt Engineer
- Enforces discipline in prompt generation
- Prevents overstepping bounds
- Makes prompts auditable and traceable

### For Forge Implementer
- Zero ambiguity about what to do
- Built-in guardrails (forbidden files)
- Clear success criteria (contract compliance)

### For Verification Agent
- Can verify output against contract
- Check file ownership
- Validate dependency installation

### For Human Operators
- Transparent: See exactly what each prompt will do
- Controllable: Reject prompts with bad contracts
- Debuggable: Trace any file back to its creating prompt

## Determinism Guarantee

Given:
- Same project rules
- Same screen index
- Same approved designs
- Same sequence index (prompt order)

Build Prompt Engineer will generate:
- **Identical execution contract**
- **Identical file lists**
- **Identical dependencies**

This determinism is critical for:
- Reproducible builds
- Audit trails
- Rollback/replay capabilities

## Future Extensions

Potential contract enhancements:
- **API contracts**: Enforce function signatures
- **Test requirements**: Mandate test coverage thresholds
- **Performance budgets**: Max file size, max dependencies
- **Security constraints**: Required security patterns

These can be added without breaking existing contracts (forward-compatible).

## Related Documentation

- [Build Prompt Engineer](../apps/server/src/agents/build-prompt-engineer.ts) - Implementation
- [Forge Implementer](./FORGE_IMPLEMENTER.md) - Execution agent (Tier 5)
- [Verification Agent](./VERIFICATION_AGENT.md) - Contract compliance checking

---

**Key Principle**: A build prompt is not just instructions - it's a binding contract between planning and execution.
